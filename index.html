<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Titel auf V3.4 aktualisiert -->
    <title>LIVE 3D Satelliten Visualisierung (V3.4 / V2.5 Architektur)</title>
    
    <style>
        /* (Der gesamte CSS-Block aus V3.3 bleibt unver√§ndert) */
        body {
            margin: 0;
            background-color: #000;
            color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        #main-container {
            display: flex;
            flex-direction: row;
            flex-grow: 1;
            overflow: hidden;
        }
        #canvas-container {
            flex-grow: 1;
            position: relative;
            cursor: grab;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #label-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            color: #00ffff;
            font-size: 1.2em;
            font-family: 'Courier New', Courier, monospace;
            text-align: center;
            padding: 20px;
            background: rgba(0,0,0,0.7);
            border-radius: 8px;
        }
         #loader.error {
            color: #ff4d4d;
         }
        #info {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 600px;
            text-align: center;
            z-index: 100;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            font-size: 0.9em;
        }
        #time-display {
            margin-top: 5px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.1em;
            color: #00ffff;
        }
        #controls {
            padding: 10px;
            background-color: #1a1a1a;
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            border-top: 1px solid #00ffff;
        }
        button, select {
            padding: 5px 10px;
            font-size: 14px;
            cursor: pointer;
            background-color: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
        }
        button:hover, select:hover {
            background-color: #00ffff;
            color: #000;
        }
        progress {
            width: 100%;
            margin-top: 10px;
        }
        .label-text {
            color: rgba(246, 255, 0, 0.691);
            background-color: transparent;
            padding: 2px 8px;
            font-size: 12px;
            font-family: 'Courier New', Courier, monospace;
            white-space: nowrap;
            border: none;
        }
        #data-sidebar {
            width: 380px;
            flex-shrink: 0;
            background-color: rgba(10, 20, 30, 0.5);
            border-left: 1px solid #00ffff;
            padding: 15px;
            box-sizing: border-box;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        #data-sidebar h3 {
            margin-top: 0;
            text-align: center;
            color: #00ffff;
            text-shadow: 0 0 2px #00ffff;
        }
        #satellite-table-container {
            flex-grow: 1;
            overflow-y: auto;
            margin-top: 10px;
        }
        #satellite-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        #satellite-table th, #satellite-table td {
            padding: 6px;
            text-align: right;
        }
        #satellite-table th {
            color: #00ffff;
            border-bottom: 1px solid #00ffff;
            position: sticky;
            top: 0;
            background: #1a1a1a;
        }
        #satellite-table td {
            color: #dddddd;
        }
        #satellite-table tr:nth-child(even) {
            background-color: rgba(0, 255, 255, 0.05);
        }
        .legend-color {
            width: 12px;
            height: 12px;
            display: inline-block;
            margin-right: 5px;
            border: 1px solid #555;
        }
        .legend-flag { margin-right: 5px; }
        
        #satellite-table-container::-webkit-scrollbar { width: 8px; }
        #satellite-table-container::-webkit-scrollbar-track { background: #1e2a38; }
        #satellite-table-container::-webkit-scrollbar-thumb { background-color: #3498db; border-radius: 4px; }
    </style>
</head>
<body>
    <div id="main-container">
        <!-- (HTML-Struktur bleibt unver√§ndert) -->
        <div id="canvas-container">
            <div id="info">
                LIVE 3D Satelliten Visualisierung (V3.4 Architektur) | Observer: <span id="latitude">--</span>, <span id="longitude">--</span>
                <div id="time-display">
                    <span id="currentTime">--:--:--</span>
                </div>
                <progress id="progressBar" value="0" max="100"></progress>
            </div>
            <div id="label-container"></div>
            <div id="loader">Lade 3D-Modelle...</div>
        </div>

        <div id="data-sidebar">
            <h3>SATELLITEN-STATUS</h3>
            <div id="legend"></div> 
            <div id="satellite-table-container">
                <table id="satellite-table">
                    <thead>
                        <tr>
                            <th>Sys</th>
                            <th>ID</th>
                            <th>Elev</th>
                            <th>Azim</th>
                            <th>SNR</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </div>

    <div id="controls">
        <!-- (Steuerungselemente bleiben unver√§ndert) -->
        <label for="range-select">Daten laden:</label>
        <select id="range-select">
            <option value="1h">Letzte 1 Std</option>
            <option value="12h">Letzte 12 Std</option>
            <option value="24h">Letzte 24 Std</option>
            <option value="7d">Letzte 7 Tage</option>
            <option value="all">Alle Daten (Vorsicht!)</option>
        </select>
        <button id="load-data-btn">Laden</button>
        <span style="border-left: 1px solid #555; height: 20px;"></span>
        
        <button id="play-pause-btn">Play</button>
        <label for="speed-slider">Speed:</label>
        <input type="range" id="speed-slider" min="1" max="1000" value="10" step="1">
        <span id="speed-display">10x</span>
        
        <label for="time-slider">Zeit (Scrub):</label>
        <input type="range" id="time-slider" min="0" max="0" value="0" style="width: 25%;">
    </div>

    <!-- (JS-Bibliotheken bleiben unver√§ndert) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    
    <script>
        // ===================================================================================
        // KONSTANTEN & BEOBACHTER-POSITION (unver√§ndert)
        // ===================================================================================
        
        let OBSERVER_LAT = 50.65; // Saalfeld Fallback
        let OBSERVER_LON = 11.36; // Saalfeld Fallback
        
        const earthRadius = 5;
        const satelliteOrbitRadius = earthRadius * ((6371 + 20200) / 6371);
        const DROPOUT_TOLERANCE_FRAMES = 18; 

        // ... (Alle 3D-Berechnungsfunktionen (calculateSatellitePosition etc.) bleiben unver√§ndert) ...
        function calculateSatellitePosition(userPosition, satInfo) {
            const userUpVector = userPosition.clone().normalize();
            const rotationQuaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), userUpVector);
            const azimRad = THREE.MathUtils.degToRad(satInfo.azim - 90);
            const elevRad = THREE.MathUtils.degToRad(satInfo.elev);
            
            const sightLineDirection = new THREE.Vector3(
                Math.cos(elevRad) * Math.cos(azimRad),
                Math.sin(elevRad),
                Math.cos(elevRad) * Math.sin(azimRad)
            );
            sightLineDirection.applyQuaternion(rotationQuaternion).normalize();

            const a = 1;
            const b = 2 * userPosition.dot(sightLineDirection);
            const c = userPosition.lengthSq() - satelliteOrbitRadius * satelliteOrbitRadius;
            const discriminant = b * b - 4 * a * c;

            if (discriminant >= 0) {
                const t = (-b + Math.sqrt(discriminant)) / (2 * a);
                return userPosition.clone().add(sightLineDirection.multiplyScalar(t));
            } else {
                return sightLineDirection.multiplyScalar(satelliteOrbitRadius);
            }
        }
        function getEarthRotationFromDatetime(datetimeString) {
            const date = new Date(datetimeString.replace(' ', 'T') + 'Z'); 
            const totalSecondsInDay = (date.getUTCHours() * 3600) + (date.getUTCMinutes() * 60) + date.getUTCSeconds();
            const fractionOfDay = totalSecondsInDay / 86400;
            return (fractionOfDay * 2 * Math.PI);
        }
        function getPositionFromLatLon(lat, lon, radius) {
            const latRad = THREE.MathUtils.degToRad(lat);
            const lonRad = THREE.MathUtils.degToRad(-lon);
            return new THREE.Vector3(
                radius * Math.cos(latRad) * Math.cos(lonRad),
                radius * Math.sin(latRad),
                radius * Math.cos(latRad) * Math.sin(lonRad)
            );
        }
        
        // ===================================================================================
        // GLOBALE VARIABLEN
        // ===================================================================================
        
        let scene, camera, renderer, labelRenderer, controls, earth, userArrow, directionalLight, starField;
        let satelliteModel;
        
        let satelliteData = []; 
        let satelliteObjects = new Map(); 
        let isPaused = true;
        let playbackSpeed = 10;
        let timeAccumulator = 0;
        let clock = new THREE.Clock();
        let maxTrailPoints = 800;
        
        // --- V3.4 √ÑNDERUNG: "Time Jump" Detektor ---
        let lastFrameIndex = -1; // -1, um den ersten Frame (0) als "Sprung" zu erkennen

        const loaderElement = document.getElementById('loader');
        // ... (Restliche globale Variablen unver√§ndert)
        const progressBar = document.getElementById('progressBar');
        const canvasContainer = document.getElementById('canvas-container');
        const labelContainer = document.getElementById('label-container');
        const currentTimeEl = document.getElementById('currentTime');
        const satelliteTableBody = document.querySelector('#satellite-table tbody');
        const slider = document.getElementById('time-slider');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const speedSlider = document.getElementById('speed-slider');
        const speedDisplay = document.getElementById('speed-display');
        const loadDataBtn = document.getElementById('load-data-btn');
        const rangeSelect = document.getElementById('range-select');

        // ===================================================================================
        // DATENVERARBEITUNG (V3.2-Logik bleibt unver√§ndert)
        // ===================================================================================

        async function loadModelsAndInitScene() {
             try {
                const gltfLoader = new THREE.GLTFLoader();
                const earthPromise = gltfLoader.loadAsync('earth.glb'); 
                const satellitePromise = gltfLoader.loadAsync('satellite.glb'); 
                const [earthGltf, satelliteGltf] = await Promise.all([earthPromise, satellitePromise]);
                
                earth = earthGltf.scene;
                satelliteModel = satelliteGltf.scene;
                
                init(); 
                loaderElement.style.display = 'none';

             } catch (error) {
                console.error("Fehler beim Laden der 3D-Modelle:", error);
                loaderElement.textContent = `Fehler: ${error.message}. Modelle (earth.glb, satellite.glb) nicht gefunden.`;
                loaderElement.classList.add('error');
             }
        }
        
        async function loadData() {
            const range = rangeSelect.value;
            loaderElement.textContent = `Lade Daten f√ºr "${range}"...`;
            loaderElement.classList.remove('error');
            loaderElement.style.display = 'block';
            
            if (!isPaused) togglePlayPause();
            removeAllSatellites(); // Wichtig: l√∂scht alte Satelliten
            satelliteData = [];
            
            try {
                // Ruft die V2.4 API auf
                const response = await fetch(`get_data.php?range=${range}&t=${new Date().getTime()}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP-Fehler! Status: ${response.status}`);
                }
                const data = await response.json();
                
                loaderElement.style.display = 'none';
                processJSONData(data); // V3.2 Logik

            } catch (error) {
                console.error("Fehler beim Laden der Daten:", error);
                loaderElement.textContent = `Fehler: ${error.message}. Stelle sicher, dass get_data.php (V2.4) funktioniert.`;
                loaderElement.classList.add('error');
            }
        }
        
        function processJSONData(data) {
            satelliteData = data;
            
            // V3.2 Bugfix (unver√§ndert)
            if (!satelliteData || satelliteData.length === 0) {
                console.warn("Keine g√ºltigen Daten vom Server empfangen (leeres Array).");
                loaderElement.textContent = 'Keine Daten f√ºr diesen Zeitraum gefunden.';
                loaderElement.classList.add('error');
                loaderElement.style.display = 'block';
                slider.max = 0;
                slider.value = 0;
                progressBar.max = 0;
                progressBar.value = 0;
                return;
            }

            slider.max = satelliteData.length - 1;
            progressBar.max = satelliteData.length - 1;
            slider.value = 0;
            progressBar.value = 0;
            
            OBSERVER_LAT = (satelliteData[0]?.lat ?? 0.0);
            OBSERVER_LON = (satelliteData[0]?.lon ?? 0.0);
            
            if (OBSERVER_LAT === 0.0) {
                 console.warn("Erster Frame hatte keine Lat/Lon. Nutze Fallback.");
                 OBSERVER_LAT = 50.65; // Fallback
                 OBSERVER_LON = 11.36; // Fallback
            }
            
            document.getElementById('latitude').innerText = OBSERVER_LAT.toFixed(4);
            document.getElementById('longitude').innerText = OBSERVER_LON.toFixed(4);

            updateFrameData(0); // Ersten Frame zeichnen
            console.log(`JSON verarbeitet. ${satelliteData.length} Sekunden-Frames geladen.`);
        }


        // ===================================================================================
        // 3D-SETUP & SZENE (unver√§ndert)
        // ===================================================================================
        
        function init() {
            // ... (Code unver√§ndert) ...
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 1000);
            camera.position.set(0, 20, 40);
            camera.lookAt(scene.position);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            canvasContainer.appendChild(renderer.domElement);
            labelRenderer = new THREE.CSS2DRenderer();
            labelRenderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            labelContainer.appendChild(labelRenderer.domElement);
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            scene.add(new THREE.AmbientLight(0x888888));
            directionalLight = new THREE.DirectionalLight(0xffffff, 2.0);
            scene.add(directionalLight);
            earth.scale.set(earthRadius, earthRadius, earthRadius);
            scene.add(earth);
            userArrow = new THREE.ArrowHelper(new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 0, 0), 0.8, 0xff0000, 0.2, 0.1);
            earth.add(userArrow);
            createBackground();
            createLegend();
            setupEventListeners();
            animate();
        }

        function createBackground() {
            // ... (Code unver√§ndert) ...
            const starsGeometry = new THREE.BufferGeometry();
            const starsCount = 10000;
            const posArray = new Float32Array(starsCount * 3);
            for (let i = 0; i < starsCount; i++) {
                const radius = 300, theta = 2 * Math.PI * Math.random(), phi = Math.acos(2 * Math.random() - 1);
                posArray[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                posArray[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                posArray[i * 3 + 2] = radius * Math.cos(phi);
            }
            starsGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const starsMaterial = new THREE.PointsMaterial({ size: 0.2, color: 0xffffff });
            starField = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(starField);
            const planeGeometry = new THREE.PlaneGeometry(200, 200, 100, 100);
            planeGeometry.rotateX(-Math.PI / 2);
            const planeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.25 });
            const gravityGrid = new THREE.Mesh(planeGeometry, planeMaterial);
            gravityGrid.position.y = -15;
            scene.add(gravityGrid);
        }

        function createLegend() {
            // ... (Code unver√§ndert) ...
            const legendDiv = document.getElementById('legend');
            const systems = [
                { name: 'GPS (USA)', flag: 'üá∫üá∏', colorKey: 'GPS' },
                { name: 'GLONASS (Russ.)', flag: 'üá∑üá∫', colorKey: 'GLONASS' },
                { name: 'BeiDou (China)', flag: 'üá®üá≥', colorKey: 'BeiDou' },
                { name: 'Galileo (EU)', flag: 'üá™üá∫', colorKey: 'Galileo' },
                { name: 'Andere', flag: 'üõ∞Ô∏è', colorKey: 'Other' }
            ];
            let html = '<strong>Legende</strong><hr style="border-color: #333; margin: 5px 0 8px 0;">';
            systems.forEach(sys => {
                const colorHex = getSatColor(sys.colorKey).toString(16).padStart(6, '0');
                html += `<div style="display: flex; align-items: center; margin-bottom: 5px;">
                    <span class="legend-flag">${sys.flag}</span>
                    <div class="legend-color" style="background-color: #${colorHex};"></div>
                    <span>${sys.name}</span>
                </div>`;
            });
            legendDiv.innerHTML = html;
        }

        function setupEventListeners() {
            // ... (Code unver√§ndert) ...
            loadDataBtn.addEventListener('click', () => loadData());
            slider.addEventListener('input', (e) => {
                if (!isPaused) togglePlayPause();
                updateFrameData(parseInt(e.target.value));
            });
            playPauseBtn.addEventListener('click', togglePlayPause);
            speedSlider.addEventListener('input', (e) => {
                let val = parseInt(e.target.value);
                if (val <= 100) {
                    playbackSpeed = val;
                    speedDisplay.textContent = `${val}x`;
                } else if (val <= 900) { 
                    let scaled = Math.round(val / 10) * 10;
                    playbackSpeed = scaled;
                    speedDisplay.textContent = `${scaled}x`;
                } else { 
                    playbackSpeed = 1000;
                    speedDisplay.textContent = `1000x`;
                }
            });
            window.addEventListener('resize', onWindowResize, false);
        }

        function togglePlayPause() {
            // ... (Code unver√§ndert) ...
            isPaused = !isPaused;
            playPauseBtn.textContent = isPaused ? "Play" : "Pause";
            clock.getDelta(); 
        }
        function getSatColor(system) {
            // ... (Code unver√§ndert) ...
            if (system.startsWith('G')) return 0x00ff00; 
            if (system.startsWith('R')) return 0xff0000; 
            if (system.startsWith('C')) return 0x0000ff; 
            if (system.startsWith('E')) return 0xffff00; 
            return 0xffffff; 
        }
        function getFlag(system) {
            // ... (Code unver√§ndert) ...
            if (system.startsWith('G')) return 'üá∫üá∏';
            if (system.startsWith('R')) return 'üá∑üá∫';
            if (system.startsWith('C')) return 'üá®üá≥';
            if (system.startsWith('E')) return 'üá™üá∫';
            return 'üõ∞Ô∏è';
        }
        function removeSatellite(id) {
            // (V3.1 Bugfix - unver√§ndert)
            if (satelliteObjects.has(id)) {
                const so = satelliteObjects.get(id);
                if (so.label) so.mesh.remove(so.label); 
                scene.remove(so.mesh); 
                so.trailSegments.forEach(seg => scene.remove(seg.line)); 
                so.tableRow.remove(); 
                satelliteObjects.delete(id);
            }
        }
        
        function removeAllSatellites() {
            // (V3.2 Logik - unver√§ndert)
            satelliteObjects.forEach(so => {
                if (so.label) so.mesh.remove(so.label);
                scene.remove(so.mesh);
                so.trailSegments.forEach(seg => scene.remove(seg.line));
                so.tableRow.remove();
            });
            satelliteObjects.clear();
            satelliteTableBody.innerHTML = '';
            
            // --- V3.4 √ÑNDERUNG ---
            // Setze den Index zur√ºck, damit der n√§chste Frame (0) als "Sprung" erkannt wird
            lastFrameIndex = -1;
        }

        function createSatellite(satData) {
            // (Code unver√§ndert)
            const newSatellite = satelliteModel.clone();
            newSatellite.scale.set(0.1, 0.1, 0.1);
            newSatellite.visible = false; 
            const textDiv = document.createElement('div');
            textDiv.className = 'label-text';
            textDiv.textContent = satData.id;
            const label = new THREE.CSS2DObject(textDiv);
            label.position.set(0, 0.5, 0);
            newSatellite.add(label);
            scene.add(newSatellite);
            const row = satelliteTableBody.insertRow();
            row.id = `sat-row-${satData.id}`;
            const colorHex = getSatColor(satData.id).toString(16).padStart(6, '0');
            row.innerHTML = `
                <td>${getFlag(satData.id)}</td>
                <td>${satData.id}</td>
                <td class="elev">--</td>
                <td class="azim">--</td>
                <td class="snr">--</td>
            `;
            row.cells[2].style.textAlign = 'right';
            row.cells[3].style.textAlign = 'right';
            row.cells[4].style.textAlign = 'right';
            const satObject = {
                id: satData.id,
                mesh: newSatellite,
                label: label,
                tableRow: row,
                targetPosition: new THREE.Vector3(),
                trailSegments: [],
                framesSinceDisappeared: 0 
            };
            satelliteObjects.set(satData.id, satObject);
            return satObject;
        }

        // ===================================================================================
        // V3.4 UPDATE-LOGIK (DER "WRAP-AROUND" FIX)
        // ===================================================================================
        function updateFrameData(index) {
            if (index < 0 || index >= satelliteData.length) return;
            
            // --- V3.4 √ÑNDERUNG: "Time Jump" Detektor ---
            // Pr√ºft, ob der Frame der n√§chste in der Sequenz ist.
            // (Falsch bei Loop, Scrub oder erstem Frame)
            const isASequentialFrame = (index === lastFrameIndex + 1);
            lastFrameIndex = index; // Aktualisiere den Index f√ºr den n√§chsten Durchlauf
            
            const currentFrame = satelliteData[index];

            // V3.2 Bugfix (unver√§ndert)
            if (!currentFrame || !currentFrame.satellites || !currentFrame.datetime) {
                console.warn(`Frame-Daten f√ºr Index ${index} sind ung√ºltig.`, currentFrame);
                return; 
            }

            // --- (Code f√ºr Erde, Pfeil, Licht, Zeitstempel - unver√§ndert) ---
            earth.rotation.y = getEarthRotationFromDatetime(currentFrame.datetime);
            const userLocalPosition = getPositionFromLatLon(currentFrame.lat, currentFrame.lon, 1);
            userArrow.position.copy(userLocalPosition);
            userArrow.setDirection(userLocalPosition.clone().normalize().negate());
            const userWorldPosition = new THREE.Vector3();
            userArrow.getWorldPosition(userWorldPosition);
            directionalLight.position.copy(userWorldPosition).normalize().multiplyScalar(50);
            currentTimeEl.textContent = currentFrame.datetime;
            progressBar.value = index;
            // --- (Ende) ---
            
            const frameSatellites = new Map();
            if (Array.isArray(currentFrame.satellites)) {
                 currentFrame.satellites.forEach(s => {
                    frameSatellites.set(s.id, s);
                 });
            }
            
            // --- SCHLEIFE 1: AKTUALISIERE SICHTBARE SATELLITEN ---
            frameSatellites.forEach(satData => {
                let so = satelliteObjects.get(satData.id);

                if (satData.elev <= 0) {
                    if (so) removeSatellite(satData.id); 
                    return; 
                }

                if (!so) {
                    so = createSatellite(satData);
                }
                
                so.mesh.visible = true;
                so.label.visible = true;
                so.targetPosition.copy(calculateSatellitePosition(userWorldPosition, satData));
                so.label.element.textContent = satData.id;
                
                // --- V3.4 √ÑNDERUNG: TRAIL-LOGIK ---
                // Starte einen neuen Trail, wenn:
                // 1. Es ein Zeit-Sprung ist (Loop/Scrub)
                // 2. Der Satellit nach einem Dropout wieder auftaucht
                if (!isASequentialFrame || so.framesSinceDisappeared > DROPOUT_TOLERANCE_FRAMES) {
                    const trailPoints = []; // Starte einen neuen, leeren Trail
                    const trailGeometry = new THREE.BufferGeometry().setFromPoints(trailPoints);
                    const trailMaterial = new THREE.LineBasicMaterial({ color: getSatColor(satData.id), transparent: true, opacity: 0.5 });
                    const trailLine = new THREE.Line(trailGeometry, trailMaterial);
                    scene.add(trailLine);
                    
                    // Optional: Alte Segmente l√∂schen, wenn es zu viele werden
                    if (so.trailSegments.length > 10) { 
                         scene.remove(so.trailSegments.shift().line);
                    }
                    
                    so.trailSegments.push({ points: trailPoints, line: trailLine });
                }
                so.framesSinceDisappeared = 0; // Setze "vermisst"-Z√§hler zur√ºck
                
                // Failsafe: Erstelle ersten Trail (falls n√∂tig)
                if (so.trailSegments.length === 0) {
                    const trailPoints = [];
                    const trailGeometry = new THREE.BufferGeometry().setFromPoints(trailPoints);
                    const trailMaterial = new THREE.LineBasicMaterial({ color: getSatColor(satData.id), transparent: true, opacity: 0.5 });
                    const trailLine = new THREE.Line(trailGeometry, trailMaterial);
                    scene.add(trailLine);
                    so.trailSegments.push({ points: trailPoints, line: trailLine });
                }
                
                // F√ºge Punkt zum *aktuellen* (neuesten) Trail hinzu
                const currentSegment = so.trailSegments[so.trailSegments.length - 1];
                currentSegment.points.push(so.targetPosition.clone());
                if (currentSegment.points.length > maxTrailPoints && maxTrailPoints < 10000) {
                    currentSegment.points.shift(); 
                }

                // Aktualisiere die Tabelle
                so.tableRow.style.color = '#ddd'; 
                so.tableRow.cells[2].textContent = `${satData.elev}¬∞`;
                so.tableRow.cells[3].textContent = `${satData.azim}¬∞`;
                so.tableRow.cells[4].textContent = satData.snr;
            });
            
            // --- SCHLEIFE 2: BEHANDLE VERMISSTE SATELLITEN (V3.3-Logik) ---
            satelliteObjects.forEach(so => {
                if (!frameSatellites.has(so.id)) {
                    so.framesSinceDisappeared++;
                    
                    // Satellit "verweilt" (bleibt sichtbar)
                    // Graue ihn nur in der Tabelle aus
                    so.tableRow.style.color = '#777'; 
                    so.tableRow.cells[2].textContent = '--';
                    so.tableRow.cells[3].textContent = '--';
                    so.tableRow.cells[4].textContent = '--';
                }
            });
        }

        // ... (animate(), onWindowResize() bleiben unver√§ndert) ...
        function animate() {
            requestAnimationFrame(animate);
            if (!isPaused) controls.update(); 

            const deltaTime = clock.getDelta();

            if (!isPaused && satelliteData.length > 0) {
                timeAccumulator += deltaTime;
                const timePerFrame = 1.0 / playbackSpeed; 

                while (timeAccumulator >= timePerFrame) {
                    timeAccumulator -= timePerFrame;
                    let newIndex = parseInt(slider.value) + 1;
                    if (newIndex >= satelliteData.length) {
                        newIndex = 0; // Der Loop-Punkt
                    }
                    slider.value = newIndex; 
                    updateFrameData(newIndex); // Ruft V3.4 Logik auf
                }
            }

            satelliteObjects.forEach(so => {
                so.label.visible = so.mesh.visible;
                if (so.mesh.visible) {
                    so.mesh.position.lerp(so.targetPosition, 15 * deltaTime);
                    so.mesh.lookAt(earth.position);
                    so.mesh.rotateY(THREE.MathUtils.degToRad(-90));
                }
                // V3.4: Zeichnet jetzt *alle* Segmente (wichtig f√ºr Spr√ºnge)
                so.trailSegments.forEach(seg => {
                    seg.line.visible = seg.points.length > 1;
                    if (seg.line.visible) {
                        seg.line.geometry.setFromPoints(seg.points);
                    }
                });
            });

            if (starField) starField.rotation.y += 0.00005;

            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            labelRenderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
        }
        
        // Startet den Ladevorgang (nur 3D-Modelle)
        loadModelsAndInitScene();

    </script>
</body>
</html>