<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Satelliten Visualisierung (CSV-Loader)</title>
    <style>
        body {
            margin: 0;
            background-color: #000;
            color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        #main-container {
            display: flex;
            flex-direction: row;
            flex-grow: 1;
            overflow: hidden;
        }
        #canvas-container {
            flex-grow: 1;
            position: relative;
            cursor: grab;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #label-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 600px;
            text-align: center;
            z-index: 100;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            font-size: 0.9em;
        }
        #time-display {
            margin-top: 5px;
            font-family: 'Courier New', Courier, monospace;
        }
        #controls {
            padding: 15px;
            background-color: #1a1a1a;
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        button {
            padding: 5px 10px;
            font-size: 14px;
            cursor: pointer;
        }
        progress {
            width: 100%;
            margin-top: 10px;
        }
        .label-text {
            color: rgba(246, 255, 0, 0.691);
            background-color: transparent;
            padding: 2px 8px;
            font-size: 12px;
            font-family: 'Courier New', Courier, monospace;
            white-space: nowrap;
            border: none;
        }
        #data-sidebar {
            width: 380px; /* Etwas breiter f√ºr Flaggen */
            flex-shrink: 0;
            background-color: rgba(10, 20, 30, 0.5);
            border-left: 1px solid #00ffff;
            padding: 15px;
            box-sizing: border-box;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        #data-sidebar h3 {
            margin-top: 0;
            text-align: center;
            color: #00ffff;
            text-shadow: 0 0 2px #00ffff;
        }
        #satellite-table-container {
            flex-grow: 1;
            overflow-y: auto;
            margin-top: 10px;
        }
        #satellite-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        #satellite-table th, #satellite-table td {
            padding: 6px;
            text-align: right;
        }
        #satellite-table th {
            color: #00ffff;
            border-bottom: 1px solid #00ffff;
        }
        #satellite-table td {
            color: #dddddd;
        }
        #satellite-table tr:nth-child(even) {
            background-color: rgba(0, 255, 255, 0.05);
        }
        .legend-color {
            width: 12px;
            height: 12px;
            display: inline-block;
            margin-right: 5px;
            border: 1px solid #555;
        }
        .legend-flag { margin-right: 5px; }
        
        /* Scrollbar-Stil f√ºr Webkit-Browser */
        #satellite-table-container::-webkit-scrollbar { width: 8px; }
        #satellite-table-container::-webkit-scrollbar-track { background: #1e2a38; }
        #satellite-table-container::-webkit-scrollbar-thumb { background-color: #3498db; border-radius: 4px; }
    </style>
</head>
<body>
    <div id="main-container">
        <div id="canvas-container">
            <div id="info">
                3D Satelliten Visualisierung | Observer: <span id="latitude">50.0</span>, <span id="longitude">11.0</span>
                <div id="time-display">
                    <span id="currentTime">--:--:--</span>
                </div>
                <progress id="progressBar" value="0" max="100"></progress>
            </div>
            <div id="label-container"></div>
            <div id="loader">Lade 3D-Modelle...</div>
        </div>

        <div id="data-sidebar">
            <h3>SATELLITEN-STEUERUNG</h3>
            <div id="legend"></div> <div id="satellite-table-container">
                <table id="satellite-table">
                    <thead>
                        <tr>
                            <th>Sys</th>
                            <th>ID</th>
                            <th>Elev</th>
                            <th>Azim</th>
                            <th>Farbe</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </div>

    <div id="controls">
        <label for="csv-upload">1. CSV laden:</label>
        <input type="file" id="csv-upload" accept=".csv">
        <button id="play-pause-btn">Play</button>
        <label for="speed-slider">Speed:</label>
        <input type="range" id="speed-slider" min="1" max="60" value="1">
        <span id="speed-display">1x</span>
        <label for="time-slider">Zeit:</label>
        <input type="range" id="time-slider" min="0" max="0" value="0" style="width: 30%;">
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        // ===================================================================================
        // KONSTANTEN & BEOBACHTER-POSITION
        // ===================================================================================
        
        // DEINE FESTE POSITION (wie gew√ºnscht: 50, 11)
        const OBSERVER_LAT = 50.0;
        const OBSERVER_LON = 11.0;
        
        // Dummy-Datum, da CSV nur Zeit hat. Wichtig f√ºr Erdrotation.
        const DUMMY_DATE = "2025-01-01"; 

        const earthRadius = 5;
        const satelliteOrbitRadius = earthRadius * ((6371 + 20200) / 6371);
        const DROPOUT_TOLERANCE_FRAMES = 18; // Aus deinem alten Skript

        // ===================================================================================
        // 3D-BERECHNUNGEN (aus deinem Repo)
        // ===================================================================================

        function calculateSatellitePosition(userPosition, satInfo) {
            const userUpVector = userPosition.clone().normalize();
            const rotationQuaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), userUpVector);
            const azimRad = THREE.MathUtils.degToRad(satInfo.azim - 90);
            const elevRad = THREE.MathUtils.degToRad(satInfo.elev);
            
            const sightLineDirection = new THREE.Vector3(
                Math.cos(elevRad) * Math.cos(azimRad),
                Math.sin(elevRad),
                Math.cos(elevRad) * Math.sin(azimRad)
            );
            sightLineDirection.applyQuaternion(rotationQuaternion).normalize();

            const a = 1;
            const b = 2 * userPosition.dot(sightLineDirection);
            const c = userPosition.lengthSq() - satelliteOrbitRadius * satelliteOrbitRadius;
            const discriminant = b * b - 4 * a * c;

            if (discriminant >= 0) {
                const t = (-b + Math.sqrt(discriminant)) / (2 * a);
                return userPosition.clone().add(sightLineDirection.multiplyScalar(t));
            } else {
                return sightLineDirection.multiplyScalar(satelliteOrbitRadius);
            }
        }

        function getEarthRotationFromDatetime(datetimeString) {
            const date = new Date(datetimeString.replace(' ', 'T') + 'Z');
            const totalSecondsInDay = (date.getUTCHours() * 3600) + (date.getUTCMinutes() * 60) + date.getUTCSeconds();
            const fractionOfDay = totalSecondsInDay / 86400;
            return (fractionOfDay * 2 * Math.PI);
        }

        function getPositionFromLatLon(lat, lon, radius) {
            const latRad = THREE.MathUtils.degToRad(lat);
            const lonRad = THREE.MathUtils.degToRad(-lon);
            return new THREE.Vector3(
                radius * Math.cos(latRad) * Math.cos(lonRad),
                radius * Math.sin(latRad),
                radius * Math.cos(latRad) * Math.sin(lonRad)
            );
        }

        // ===================================================================================
        // GLOBALE VARIABLEN
        // ===================================================================
        
        let scene, camera, renderer, labelRenderer, controls, earth, userArrow, directionalLight, starField;
        let satelliteModel;
        
        // --- NEUE/ANGEPASSTE GLOBALS ---
        let satelliteData = []; // Array aller Frames
        let satelliteObjects = new Map(); // "Ged√§chtnis" f√ºr alle aktiven Satelliten (ersetzt Array)
        let isPaused = true;
        let playbackSpeed = 1;
        let timeAccumulator = 0;
        let clock = new THREE.Clock();
        let maxTrailPoints = 800; // Aus deinem Repo (kann man wieder an Steuerung kn√ºpfen)
        
        // DOM-Elemente
        const loaderElement = document.getElementById('loader');
        const progressBar = document.getElementById('progressBar');
        const canvasContainer = document.getElementById('canvas-container');
        const labelContainer = document.getElementById('label-container');
        const currentTimeEl = document.getElementById('currentTime');
        const satelliteTableBody = document.querySelector('#satellite-table tbody');
        
        const fileInput = document.getElementById('csv-upload');
        const slider = document.getElementById('time-slider');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const speedSlider = document.getElementById('speed-slider');
        const speedDisplay = document.getElementById('speed-display');

        // ===================================================================================
        // DATENVERARBEITUNG (CSV-PARSER)
        // ===================================================================

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Reset
            satelliteData = [];
            satelliteObjects.forEach(visual => removeSatellite(visual.id));
            satelliteObjects.clear();
            satelliteTableBody.innerHTML = ''; // Tabelle leeren
            slider.value = 0;
            slider.max = 0;
            isPaused = true;
            playPauseBtn.textContent = "Play";

            const reader = new FileReader();
            reader.onload = (e) => {
                const text = e.target.result;
                parseCSV(text);
            };
            reader.readAsText(file);
        }

        function parseCSV(csvText) {
            const lines = csvText.split('\n');
            const dataMap = new Map();
            let headerSkipped = false;

            lines.forEach(line => {
                if (!line || (!headerSkipped && line.startsWith('PC_Timestamp'))) {
                    headerSkipped = true;
                    return; 
                }
                const parts = line.split(',');
                if (parts.length < 6) return;
                const fullTimestamp = parts[0].trim();
                const timestampKey = fullTimestamp.split('.')[0];
                if (!timestampKey) return;

                const sat = {
                    system: parts[1].trim(),
                    id: parts[2].trim(),
                    elev: parseFloat(parts[3]),
                    azim: parseFloat(parts[4]),
                    snr: parts[5].trim()
                };
                
                if (isNaN(sat.elev) || isNaN(sat.azim)) return;

                if (!dataMap.has(timestampKey)) {
                    dataMap.set(timestampKey, new Map()); 
                }
                dataMap.get(timestampKey).set(sat.id, sat);
            });

            // Umwandeln in das Format, das die 3D-Logik erwartet
            satelliteData = Array.from(dataMap.entries())
                .map(([time, satelliteMap]) => ({ 
                    // WICHTIG: Wir f√ºgen die festen Lat/Lon-Werte und ein Dummy-Datum hinzu
                    datetime: `${DUMMY_DATE} ${time}`, 
                    lat: OBSERVER_LAT,
                    lon: OBSERVER_LON,
                    satellites: Array.from(satelliteMap.values())
                 }))
                .sort((a, b) => a.datetime.localeCompare(b.datetime)); // Nach Zeit sortieren

            slider.max = satelliteData.length - 1;
            progressBar.max = satelliteData.length - 1;
            
            // UI aktualisieren
            document.getElementById('latitude').innerText = OBSERVER_LAT.toFixed(1);
            document.getElementById('longitude').innerText = OBSERVER_LON.toFixed(1);

            // Ersten Frame zeichnen (initialisiert die ersten Satelliten)
            updateFrameData(0); 
            console.log(`CSV verarbeitet. ${satelliteData.length} Sekunden-Frames geladen.`);
        }

        // ===================================================================================
        // 3D-SETUP & SZENE
        // ===================================================================================

        async function loadDataAndModels() {
            try {
                // PHP-Fetch ENTFERNT. L√§dt nur noch die 3D-Modelle.
                const gltfLoader = new THREE.GLTFLoader();
                const earthPromise = gltfLoader.loadAsync('earth.glb');
                const satellitePromise = gltfLoader.loadAsync('satellite.glb');
                const [earthGltf, satelliteGltf] = await Promise.all([earthPromise, satellitePromise]);
                earth = earthGltf.scene;
                satelliteModel = satelliteGltf.scene;
                init(); // Startet die Initialisierung, wenn Modelle geladen sind
            } catch (error) {
                console.error("Fehler beim Laden der 3D-Modelle:", error);
                loaderElement.textContent = `Fehler: ${error.message}. Stelle sicher, dass earth.glb und satellite.glb im selben Ordner liegen.`;
            }
        }

        function init() {
            loaderElement.style.display = 'none';
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 1000);
            camera.position.set(0, 20, 40);
            camera.lookAt(scene.position);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            canvasContainer.appendChild(renderer.domElement);

            labelRenderer = new THREE.CSS2DRenderer();
            labelRenderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            labelContainer.appendChild(labelRenderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            scene.add(new THREE.AmbientLight(0x888888));
            directionalLight = new THREE.DirectionalLight(0xffffff, 2.0);
            scene.add(directionalLight);

            earth.scale.set(earthRadius, earthRadius, earthRadius);
            scene.add(earth);

            userArrow = new THREE.ArrowHelper(new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 0, 0), 0.8, 0xff0000, 0.2, 0.1);
            earth.add(userArrow);

            createBackground();
            createLegend();
            setupEventListeners();
            animate();
        }

        function createBackground() {
            const starsGeometry = new THREE.BufferGeometry();
            const starsCount = 10000;
            const posArray = new Float32Array(starsCount * 3);
            for (let i = 0; i < starsCount; i++) {
                const radius = 300, theta = 2 * Math.PI * Math.random(), phi = Math.acos(2 * Math.random() - 1);
                posArray[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                posArray[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                posArray[i * 3 + 2] = radius * Math.cos(phi);
            }
            starsGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const starsMaterial = new THREE.PointsMaterial({ size: 0.2, color: 0xffffff });
            starField = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(starField);

            const planeGeometry = new THREE.PlaneGeometry(200, 200, 100, 100);
            planeGeometry.rotateX(-Math.PI / 2);
            // ... (Gravitationsgitter-Code aus deinem Repo)
            const planeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.25 });
            const gravityGrid = new THREE.Mesh(planeGeometry, planeMaterial);
            gravityGrid.position.y = -15;
            scene.add(gravityGrid);
        }

        function createLegend() {
            const legendDiv = document.getElementById('legend');
            const systems = [
                { name: 'GPS (USA)', flag: 'üá∫üá∏', colorKey: 'GPS' },
                { name: 'GLONASS (Russ.)', flag: 'üá∑üá∫', colorKey: 'GLONASS' },
                { name: 'BeiDou (China)', flag: 'üá®üá≥', colorKey: 'BeiDou' },
                { name: 'Galileo (EU)', flag: 'üá™üá∫', colorKey: 'Galileo' },
                { name: 'Andere', flag: 'üõ∞Ô∏è', colorKey: 'Other' }
            ];

            let html = '<strong>Legende</strong><hr style="border-color: #333; margin: 5px 0 8px 0;">';
            systems.forEach(sys => {
                const colorHex = getSatColor(sys.colorKey).toString(16).padStart(6, '0');
                html += `<div style="display: flex; align-items: center; margin-bottom: 5px;">
                    <span class="legend-flag">${sys.flag}</span>
                    <div class="legend-color" style="background-color: #${colorHex};"></div>
                    <span>${sys.name}</span>
                </div>`;
            });
            legendDiv.innerHTML = html;
        }

        function setupEventListeners() {
            // Neue Steuerung
            fileInput.addEventListener('change', handleFileUpload);
            slider.addEventListener('input', (e) => {
                if (!isPaused) togglePlayPause();
                updateFrameData(parseInt(e.target.value));
            });
            playPauseBtn.addEventListener('click', togglePlayPause);
            speedSlider.addEventListener('input', (e) => {
                playbackSpeed = parseInt(e.target.value);
                speedDisplay.textContent = `${playbackSpeed}x`;
            });
            
            // Alte Steuerung (aus Repo)
            // Die Buttons `cameraFlyBtn` etc. sind nicht mehr da,
            // k√∂nnten aber wieder hinzugef√ºgt werden.
            
            window.addEventListener('resize', onWindowResize, false);
        }

        function togglePlayPause() {
            isPaused = !isPaused;
            playPauseBtn.textContent = isPaused ? "Play" : "Pause";
            clock.getDelta(); 
        }

        function getSatColor(system) {
            if (system.startsWith('GPS')) return 0x00ff00; // Gr√ºn
            if (system.startsWith('GLONASS')) return 0xff0000; // Rot
            if (system.startsWith('BeiDou')) return 0x0000ff; // Blau
            if (system.startsWith('Galileo')) return 0xffff00; // Gelb
            return 0xffffff; // Wei√ü
        }
        
        function getFlag(system) {
            if (system.startsWith('GPS')) return 'üá∫üá∏';
            if (system.startsWith('GLONASS')) return 'üá∑üá∫';
            if (system.startsWith('BeiDou')) return 'üá®üá≥';
            if (system.startsWith('Galileo')) return 'üá™üá∫';
            return 'üõ∞Ô∏è';
        }

        // ===================================================================================
        // KERNLOGIK: ANIMATION & STATE MANAGEMENT (Stark √ºberarbeitet)
        // ===================================================================================

        // Erstellt einen NEUEN Satelliten (Mesh, Label, Trail, Tabellenzeile)
        function createSatellite(satData) {
            const newSatellite = satelliteModel.clone();
            newSatellite.scale.set(0.1, 0.1, 0.1);
            newSatellite.visible = false; // Startet unsichtbar, wird in updateFrameData sichtbar
            
            const textDiv = document.createElement('div');
            textDiv.className = 'label-text';
            textDiv.textContent = satData.id;
            const label = new THREE.CSS2DObject(textDiv);
            label.position.set(0, 0.5, 0);
            newSatellite.add(label);
            
            scene.add(newSatellite);
            
            // Tabellenzeile erstellen
            const row = satelliteTableBody.insertRow();
            row.id = `sat-row-${satData.id}`;
            const colorHex = getSatColor(satData.system).toString(16).padStart(6, '0');
            
            row.innerHTML = `
                <td>${getFlag(satData.system)}</td>
                <td>${satData.id}</td>
                <td class="elev">--</td>
                <td class="azim">--</td>
                <td><div class="legend-color" style="background-color: #${colorHex};"></div></td>
            `;

            // Objekt im "Ged√§chtnis" speichern
            const satObject = {
                id: satData.id,
                mesh: newSatellite,
                label: label,
                tableRow: row,
                targetPosition: new THREE.Vector3(),
                trailSegments: [],
                framesSinceDisappeared: 0 // Nicht mehr wirklich genutzt, aber ok
            };
            satelliteObjects.set(satData.id, satObject);
            return satObject;
        }

        // Entfernt einen Satelliten
        function removeSatellite(id) {
            if (satelliteObjects.has(id)) {
                const so = satelliteObjects.get(id);
                scene.remove(so.mesh); // Mesh & Label entfernen
                so.trailSegments.forEach(seg => scene.remove(seg.line)); // Trails entfernen
                so.tableRow.remove(); // Tabellenzeile entfernen
                satelliteObjects.delete(id);
            }
        }

        // Aktualisiert die Szene f√ºr einen bestimmten Daten-Index
        function updateFrameData(index) {
            if (index < 0 || index >= satelliteData.length) return;
            const currentFrame = satelliteData[index];

            // Erdrotation und Beobachterposition
            earth.rotation.y = getEarthRotationFromDatetime(currentFrame.datetime);
            const userLocalPosition = getPositionFromLatLon(currentFrame.lat, currentFrame.lon, 1);
            userArrow.position.copy(userLocalPosition);
            userArrow.setDirection(userLocalPosition.clone().normalize().negate());

            const userWorldPosition = new THREE.Vector3();
            userArrow.getWorldPosition(userWorldPosition);
            directionalLight.position.copy(userWorldPosition).normalize().multiplyScalar(50);

            // UI-Anzeigen
            currentTimeEl.textContent = currentFrame.datetime;
            progressBar.value = index;
            
            const frameSatellites = new Map(currentFrame.satellites.map(s => [s.id, s]));
            
            // --- NEUE PERSISTENZ-LOGIK ---
            
            // 1. Alle Satelliten aus dem aktuellen Frame verarbeiten
            frameSatellites.forEach(satData => {
                let so = satelliteObjects.get(satData.id);

                // Satellit geht unter (oder ist ung√ºltig)
                if (satData.elev <= 0) {
                    if (so) removeSatellite(satData.id); // War sichtbar, jetzt entfernen
                    return; // Nicht weiter verarbeiten
                }

                // Satellit ist neu
                if (!so) {
                    so = createSatellite(satData);
                }
                
                // Satellit ist sichtbar -> IMMER aktualisieren
                so.mesh.visible = true;
                so.targetPosition.copy(calculateSatellitePosition(userWorldPosition, satData));
                so.label.element.textContent = satData.id;
                
                // Trail-Logik (aus deinem Repo)
                if (so.framesSinceDisappeared > DROPOUT_TOLERANCE_FRAMES) {
                    const trailPoints = [];
                    const trailGeometry = new THREE.BufferGeometry().setFromPoints(trailPoints);
                    const trailMaterial = new THREE.LineBasicMaterial({ color: getSatColor(satData.system), transparent: true, opacity: 0.5 });
                    const trailLine = new THREE.Line(trailGeometry, trailMaterial);
                    scene.add(trailLine);
                    so.trailSegments.push({ points: trailPoints, line: trailLine });
                }
                so.framesSinceDisappeared = 0;
                
                if (so.trailSegments.length === 0) {
                    const trailPoints = [];
                    const trailGeometry = new THREE.BufferGeometry().setFromPoints(trailPoints);
                    const trailMaterial = new THREE.LineBasicMaterial({ color: getSatColor(satData.system), transparent: true, opacity: 0.5 });
                    const trailLine = new THREE.Line(trailGeometry, trailMaterial);
                    scene.add(trailLine);
                    so.trailSegments.push({ points: trailPoints, line: trailLine });
                }
                
                const currentSegment = so.trailSegments[so.trailSegments.length - 1];
                currentSegment.points.push(so.targetPosition.clone());
                if (currentSegment.points.length > maxTrailPoints && maxTrailPoints < 10000) {
                    currentSegment.points.shift();
                }

                // Tabelle aktualisieren
                so.tableRow.querySelector('.elev').textContent = `${satData.elev}¬∞`;
                so.tableRow.querySelector('.azim').textContent = `${satData.azim}¬∞`;
            });
            
            // 2. Satelliten, die NICHT im Frame waren (aber im Ged√§chtnis sind)
            satelliteObjects.forEach(so => {
                if (!frameSatellites.has(so.id)) {
                    // Satellit hatte in dieser Sekunde kein Update.
                    // WIR MACHEN NICHTS.
                    // Er bleibt sichtbar an seiner letzten Position.
                    so.framesSinceDisappeared++; // Z√§hler aus Repo, optional
                }
            });
        }

        // Haupt-Animations-Schleife (mit Playback-Logik)
        function animate() {
            requestAnimationFrame(animate);
            if (!isPaused) controls.update(); // Nur updaten, wenn pausiert

            const deltaTime = clock.getDelta();

            // Playback-Logik
            if (!isPaused && satelliteData.length > 0) {
                timeAccumulator += deltaTime;
                const timePerFrame = 1.0 / playbackSpeed; 

                while (timeAccumulator >= timePerFrame) {
                    timeAccumulator -= timePerFrame;
                    let newIndex = parseInt(slider.value) + 1;
                    if (newIndex >= satelliteData.length) {
                        newIndex = 0; // Loop
                    }
                    slider.value = newIndex; 
                    updateFrameData(newIndex); // Logik-Update
                }
            }

            // 3D-Updates (Interpolation) aus Repo
            satelliteObjects.forEach(so => {
                so.label.visible = so.mesh.visible;
                if (so.mesh.visible) {
                    so.mesh.position.lerp(so.targetPosition, 15 * deltaTime);
                    so.mesh.lookAt(earth.position);
                    so.mesh.rotateY(THREE.MathUtils.degToRad(-90));
                }
                so.trailSegments.forEach(seg => {
                    seg.line.visible = seg.points.length > 1;
                    if (seg.line.visible) {
                        seg.line.geometry.setFromPoints(seg.points);
                    }
                });
            });

            if (starField) starField.rotation.y += 0.00005;

            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            labelRenderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
        }

        // Startet den Ladevorgang
        loadDataAndModels();

    </script>
</body>
</html>